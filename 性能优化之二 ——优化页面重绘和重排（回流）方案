#页面的重绘和重排（回流）#

1. 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为重排或者回流(reflow)。
每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，
完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

2. 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

注意：回流必将引起重绘，而重绘不一定会引起回流。

重排何时发生：

当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器重排：

* 添加或者删除可见的DOM元素；

* 元素位置改变；

* 元素尺寸改变——边距、填充、边框、宽度和高度

* 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；

* 页面渲染初始化；

* 浏览器窗口尺寸改变——resize事件发生时；



## 如何减少重排、重绘 ##

减少回流、重绘其实就是需要减少对render tree的操作（合并多次多DOM和样式的修改），并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有：

###　直接改变className，如果动态改变样式，则使用cssText 批量操作样式style（考虑没有优化的浏览器）###

          document.getElementById("d1").style.cssText = "color:red; font-size:13px;";


### 让要操作的元素进行”离线处理”，处理完后一起更新###

*  使用DocumentFragment进行缓存操作,引发一次回流和重绘；
*  使用display:none技术，只引发两次回流和重绘；
*  使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；

重点说下DocumentFragment 的问题：动态创建一个ul节点，并绑定1000个li 节点，显示在body的第一个节点前。这个典型的问题就可以用DocumentFragment
进行缓存。

### 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存###
